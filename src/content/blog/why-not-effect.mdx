---
title: "Why we're not using Effect"
description: We evaluated the shiny new functional programming library
pubDate: October 23, 2024
author: Tom MacWright
---

Val Town's backend is a pretty complex application. We're running user code, proxying [blob storage](https://docs.val.town/std/blob/) and other services, storing observability data, running [intervals](https://docs.val.town/types/cron/), and a lot more.

One of the things that makes it complicated is the wide variety of error states. There are simple errors, like when a client supplies us with an invalid input, but there are a lot of more sophisticated errors, like when a val has invalid dependencies or syntax, and then when Vals fail with errors when operating as [HTTP endpoints](https://docs.val.town/types/http/) or [cron triggers](https://docs.val.town/types/cron/). Distinguishing between internal and external, recoverable and non-recoverable errors, is pretty crucial.

We also have some pretty sophisticated asynchronous code. Vals should run as fast as possible, which means that we parallelize some operations and defer others. There are some pretty tricky functions that string it all together.

I recently evaluated [Effect](https://effect.website/) as a better framework for solving these problems. It makes up for some of TypeScript's main deficiencies in error handling and concurrency: in TypeScript, thrown errors and rejected promises do not have error types. And concurrency is, by default, unbounded. Effect provides many fundamental tools for dealing with complex operations, and I've been taken in by the rave reviews it has gotten from [Dillon](https://x.com/dillon_mulroy) amongst other fans.

I'm no stranger to the functional programming world: I used [Rambda](https://ramdajs.com/) in a large-scale project in the past, and [Purify](https://github.com/gigobyte/purify) more recently. I'm completely sold on the value of typed errors, and I think that `Either`, `Option`, and `Maybe` types are generally good ideas.

So I dove into Effect for a few days, and we decided as a team not to use it. Here's why.

## Documentation

The biggest concern right at the top: documentation. Effect has [narrative documentation](https://effect.website/docs/quickstart), as well as [API documentation](https://effect-ts.github.io/effect/docs/effect), but there are a lot of missing details.

I think in large part this is because the API surface – the number of functions and variables exported by Effect – is enormous. But regardless, there are just so many core APIs that are undocumented. Like take `Effect.gen`, the function that lets you run a series of effects using a generator and get the result at the end: [it has no JSDoc documentation at all](https://effect-ts.github.io/effect/effect/Either.ts.html#gen). The same for nearly all of the functional shorthand methods like [ap, product, and productMany](https://effect-ts.github.io/effect/effect/Option.ts.html#ap) on the Option and Effect types. I ran into undocumented APIs constantly when I was reading code examples and writing new code.

The narrative documentation leaves a lot to be desired: in the extremely brief documentation about running effects, it recommends you use [Effect.runFork](https://effect.website/docs/guides/essentials/running-effects#runfork), but only provides a contrived example that doesn't show you how to do something like get the result of the computation, or an error, or really use the `runFork` method in practice.

I wouldn't feel comfortable using Effect throughout our application without solid documentation to point to: it would be a problem for onboarding new developers to Val Town's codebase.

Effect is a really big project. The core `effect` module has a lot of functionality, but there are [six extra ecosystem modules](https://effect.website/docs/other/api-reference) listed in the documentation, and a lot of other unstable modules that are still in development, like `@effect/sql-drizzle`. There are concepts that need documentation, too - Effect [3.10](https://effect.website/blog/effect-3.10#redactable-trait) includes a new Redactable trait, but I can't figure out what traits are - there are [two examples](https://effect.website/docs/other/trait), but no explanation of what "trait" means.

I'm excited for when that ecosystem of extra modules stabilizes: I could see the Effect stack being revolutionary for TypeScript development.

## Interoperability

Something I liked about Purify was that it was a relatively small abstraction. It just supported a few functional programming-flavored data types, and worked well with existing code.

Effect's style, on the other hand, tends to take over the codebase: you want to combine Effects and only actually _run_ them once. But this meant that more and more of the codebase started to have to adopt Effect - we would have to use it in the tests, for which there's [`@effect/vitest`](https://effect-ts.github.io/effect/vitest/index.ts.html), which lacks any JSDoc documentation, but at least [has a readme](https://www.npmjs.com/package/@effect/vitest).

Interoperating with the existing parts of our stack would, as far as I can tell, have us using those ecosystem parts, like `@effect/sql-drizzle`. But there isn't even [a README](https://www.npmjs.com/package/@effect/sql-drizzle/v/0.16.6) for that module: we can't make that part of our onboarding.

Val Town is not a greenfield project at this point. We have a lot of functionality that we want to keep supporting, and we studiously avoid [the big rewrite](https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/). Adopting Effect would mean _incrementally_ adopting it in our mixed-paradigm, mostly-imperative codebase.

## What we're doing instead

For now, we're going to just use TypeScript error handling, but I plan to try out [neverthrow](https://github.com/supermacro/neverthrow), which is a lighter-weight abstraction and just gives an `Either`-like abstraction for capturing the types of errors.

Honestly, I like a lot of things about Effect: I think that TypeScript really does need better abstractions, and Effect is providing them. And it's exciting that the project seems to have a full-time team and [startup company](https://effectful.co/) behind it. Hopefully they fix the ratio of API surface to documentation surface, and it'll become something that I'd be comfortable including in a production application. I think it's always going to be a little intimidating because functional programming concepts
are not very mainstream, but there's a lot that this team could do to promote them.
